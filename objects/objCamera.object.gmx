<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>objActor</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Set up camera
event_inherited();
d3d_start();
target = objPlayer; //Target must be objActor child
range = 80;
pitch = 0;
radius = 1;
height = 2;
fGravity = false;
fVisible = false;
fGhost = true;
fShadow = false;
//Set first person zooming
mode = 0; //0 - normal, 1 - first person, 2 - free scroll
bob = 0;
flinch = 0;
sensX = 10;
sensY = 10;
previousZ = 0;
//Set global variables
global.cX = 0;
global.cY = 0;
global.cZ = 0;
global.cD = 0;
global.cP = 0;
audio_emitter_free(emitter);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Turn off D3D
d3d_end();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Normalize direction
faceDir = angle_normalize(faceDir);
global.cD = faceDir;
global.cP = pitch;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="23">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Attach camera to target
var cursor = cr_default;
if (mode) cursor = cr_none;
window_set_cursor(cursor);
if (target &amp;&amp; instance_exists(target))
{
    if !(cutscene_exists()) mouse_look(false);
    if (!cutscene_exists() || (cutscene_exists() &amp;&amp; global.follow))
    {
        var lookVec = lengthdir_y(8, angle_difference(target.faceDir, faceDir));
        x = target.x - lengthdir_x(range, faceDir) - lengthdir_x(lookVec, faceDir + 90);
        y = target.y - lengthdir_y(range, faceDir) - lengthdir_y(lookVec, faceDir + 90);
        z = max(target.z + 12, global.minZ);
        global.cX = x;
        global.cY = y;
        global.cZ = z;
        global.cD = faceDir;
        global.cP = pitch;
    }
    /*if (cutscene_exists())
    {
        mode = 0;
        target.fVisible = true;
    }
    if (!cutscene_exists() || (cutscene_exists() &amp;&amp; global.follow))
    {
        //Ready up target coordinates
        var tX = target.x, tY = target.y, tRZ = target.bottom, tZ = tRZ, tZS = target.zSpeed, tSZ = target.shadowZ, tD = target.faceDir;
        tZ = previousZ;
        if (target.fOnGround &amp;&amp; tSZ != -65536) previousZ = tSZ;
        if (tRZ &lt; previousZ - 10|| tRZ &gt; previousZ + 40) tZ = tRZ;
        if (target.hp &amp;&amp; !cutscene_exists())
        {
            //Toggle freelook
            if (global.bind[8, 3])
            {
                if (mode == 2)
                {
                    mode = 0;
                    audio_play_sound(global.snd[| cSndCameraOut], 1, false);
                }
                else
                {
                    mode = 2;
                    audio_play_sound(global.snd[| cSndCameraIn], 1, false);
                }
                target.fVisible = true;
            }
            //Toggle aiming
            if (global.bind[9, 3])
            {
                if (mode == 1)
                {
                    mode = 0;
                    target.fVisible = true;
                    target.faceDir = faceDir;
                    audio_play_sound(global.snd[| cSndCameraOut], 1, false);
                }
                else
                {
                    mode = 1;
                    target.fVisible = false;
                    faceDir = tD;
                    audio_play_sound(global.snd[| cSndCameraIn], 1, false);
                }
                pitch = 0;
            }
        }
        else mode = 0;
        //Camera mechanics
        flinch = lerp(flinch, 0, 0.05);
        if (mode == 1)
        {
            global.cX = tX;
            global.cY = tY;
            var b = 0;
            if (target.fOnGround &amp;&amp; target.fric == 0.2) b = lengthdir_y(target.spdDis * 3, current_time * 0.85);
            if (target.sliding || target.fric != 0.2) b = -6;
            bob = lerp(bob, b, 0.05);
            global.cZ = target.top - 4 + bob;
            //Mouselook
            mouse_look();
            target.faceDir = global.cD;
        }
        else
        {
            var lerpAmount = 0.18;
            //Freelook
            if (mode == 2)
            {
                mouse_look();
                lerpAmount = 0.5;
            }
            else if (global.bind[7, 3] &amp;&amp; faceDir != tD)
            {
                faceDir = tD;
                audio_play_sound(global.snd[| cSndCamera], 1, false);
            }
            //Set the increments of the camera to zoom out for 3rd person
            var incX = lengthdir_x(range, faceDir), incY = lengthdir_y(range, faceDir), incZ = 0, obstructed = false, tBlockZ = tRZ + 24, tBlockZ2 = tZ + 24, tToX = tX - incX, tToY = tY - incY, tToZ = tBlockZ2, maxPitch = 89.5, minPitch = -89.5;
            if (mode == 2)
            {
                incX = lengthdir_x(lengthdir_x(range, faceDir), pitch);
                incY = lengthdir_x(lengthdir_y(range, faceDir), pitch);
                incZ = lengthdir_y(range, pitch);
                tToX = tX - incX;
                tToY = tY - incY;
                tToZ = tBlockZ2 + incZ;
            }
            //If there is a block behind...
            if (c_raycast_world(tX, tY, tBlockZ, tX - incX, tY - incY, tBlockZ + incZ, 1))
            {
                tToX = c_hit_x();
                tToY = c_hit_y();
                tToZ = c_hit_z();
                obstructed = true;
            }
            if (obstructed)
            {
                tBlockZ2 = tZ + 10;
                if (mode == 2) tToZ = tBlockZ2 + incZ;
            }
            //smooth turning
            global.cX = lerp(global.cX, tToX, lerpAmount);
            global.cY = lerp(global.cY, tToY, lerpAmount);
            global.cZ = max(global.minZ, lerp(global.cZ, tToZ, 0.1));
            x = global.cX;
            y = global.cY;
            z = global.cZ;
            if !(mode == 2) pitch += turn_to_angle(point_pitch(global.cX, global.cY, global.cZ, tX, tY, tBlockZ2 - 10), 2, pitch);
            else
            {
                minPitch = -45;
                maxPitch = 0;
            }
            pitch = clamp(pitch, minPitch, maxPitch);
        }
    }*/
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Rendering
draw_set_color(c_white);
var realPitch = pitch;
if (mode == 1) realPitch = clamp(pitch + flinch, -89.5, 89.5); //Add flinching if first person mode
var cCos = dcos(global.cD), cSin = dsin(global.cD), cTan = dtan(realPitch), i = 0;
d3d_set_projection_ext(global.cX, global.cY, global.cZ, global.cX + cCos, global.cY - cSin, global.cZ + cTan, 0, 0, 1, 45, view_wview[0] / view_hview[0], 1, global.maxRender);
audio_listener_position(global.cX, global.cY, global.cZ);
audio_listener_orientation(cCos, -cSin, cTan, 0, 0, 1);
//Draw the skybox
if (global.skybox != noone)
{
    d3d_set_zwriteenable(false);
    d3d_draw_ellipsoid(global.cX + 128, global.cY + 128, global.cZ + 256, global.cX - 128, global.cY - 128, global.cZ - 256, texture_get(global.skybox), 1, -1, 32);
    d3d_set_zwriteenable(true);
}
//Draw world model
texture_set_repeat(true);
repeat (ds_list_size(global.worldModel[0]))
{
    vertex_submit(ds_list_find_value(global.worldModel[0], i), pr_trianglelist, texture_get(ds_list_find_value(global.worldModel[1], i)));
    i++;
}
texture_set_repeat(false);
//Draw actors
with (objActor)
{
    if (fVisible &amp;&amp; sprite != -1)
    { 
        var getSprite = sprite_get(sprite), getType = sprite_type(sprite);
        switch (getType)
        {
            case (0):
            case (1):
                var cFrame = frame, size = scale * 0.5;
                matrix_set(matrix_world, matrix_build(x, y, bottom, -90, global.cD - 90, 0, size, size, size));
                if (getType)
                {
                    var dir = (round((point_direction(x, y, global.cX, global.cY) - faceDir) / 90)) mod (4), frames = image_get_number(getSprite);
                    while (dir &lt; 0) dir += 4;
                    cFrame = min(((frames * 0.25) * dir) + frame, frames - 1);
                }
                draw_image_ext(getSprite, cFrame, 0, 0, 1, -1, 0, c_white, 1);
                smf_matrix_reset();
            break
            case (2):
                matrix_set(matrix_world, matrix_build(x, y, bottom, 0, 0, faceDir, scale, scale, scale));
                shader_set(sh_smf_animate);
                var i, submodels = getSprite[| 0], bodygroups = getSprite[| 1], animation = getSprite[| 2 + anim];
                smf_animation_set_shader_uniforms(sh_smf_animate, smf_sample_blend(animation[| frame], animation[| (frame + 1) mod (ds_list_size(animation))], frac(frame)));
                //Submodels
                i = 0;
                repeat (ds_list_size(submodels))
                {
                    if (skin[i] == -1) continue //Don't draw disabled submodels
                    var submodel = submodels[| i];
                    smf_model_draw(submodel[| 0], global.mtl[| submodel[| 1 + skin[i]]]);
                    i++;
                }
                //Bodygroups
                i = 0;
                repeat (ds_list_size(bodygroups))
                {
                    if (bodygroup[i] == -1) continue //Don't draw disabled bodygroups
                    var bgModel = bodygroups[| i];
                    smf_model_draw(bgModel[| 1 + bodygroup[i]], global.mtl[| bgModel[| 0]]);
                    i++;
                }
                shader_reset();
            break
        }
    }
    if (fShadow &amp;&amp; shadowZ != -65536 &amp;&amp; global.cZ &gt; shadowZ)
    {
        matrix_set(matrix_world, shadowMatrix);
        var shadowSize = 2 * radius;
        draw_image_stretched_ext(global.bg[| cBgShadow], 0, -radius, -radius, shadowSize, shadowSize, c_white, 0.5);
    }
}
matrix_set(matrix_world, SMF_MATIDENTITY);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
