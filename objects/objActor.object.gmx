<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Create actor
//Actions
hp = 0;
target = noone;
//Flags
fOnGround = true; //Used to check if the actor is on the ground, to do specific things.
fGravity = true;
fGhost = false; //Turn on if you don't want the actor to have collision checking.
fVisible = true;
fShadow = true;
fEnemy = false; //Used by objEnemy.
fSolid = false;
fPushable = false; //Turn on if you want the actor to get pushed back when touching other actors.
fBounce = false; //Turn on if you want the actor to bounce from walls and floors. You can also change the bounciness value.
//Physics
z = 8;
radius = 4; //The radius is the actor's width split in half, i.e. 8 = 4.
height = 16;
half = 8; //The center point of the actor's height.
top = 16; //The bottom of the actor's z position.
bottom = 0; //The top of the z position.
hSpeed = 0;
vSpeed = 0;
zSpeed = 0;
bounciness = 1; //Bounciness is calculated by spd divided by bounciness. Less is more.
faceDir = 0;
floorAngle = 0; //Used for checking the direction of slopes.
floorPitch = 0; //Used for checking the vertical angle of slopes and detecting steep surfaces.
sliding = false; //Used for sliding off of steep slopes.
fric = 0; //Used for deacceleration.
//Animation
shadowZ = -9;
shadowMatrix = SMF_MATIDENTITY;
sprite = -1;
frame = 0; //Similar to image_index.
frameSpd = 0; //Similar to image_speed.
//anim, skin and bodygroup are only used for animated models
anim = 0;
skin = 0;
bodygroup = 0;
scale = 1; //scale is used for changing the actor's sprite size. Does not affect hitbox.
emitter = audio_emitter_create();
audio_emitter_falloff(emitter, 85.5, 170.5, 1);
timer_create();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Clear used memory
actor_clear();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Animation &amp; physics
//Keep the facing direction in range.
faceDir = angle_normalize(faceDir);
//Update sprite
actor_sprite_update();
/*Shadow position
The shadowZ will always be at -65536 if no floor is detected.
NOTE: disabling an actor's shadow will also disable speed changing and sliding on slopes.*/
if (fShadow)
    if (c_raycast_world(x, y, z, x, y, z - 65536, 1))
    {
        shadowZ = c_hit_z() + 0.1;
        var normalX = c_hit_nx(), normalY = c_hit_ny(), normalZ = c_hit_nz();
        //Change the shadow's rotation using a matrix based off of the hit triangle's normals.
        shadowMatrix = world_matrix_from_normal(c_hit_nx(), c_hit_ny(), normalZ, x, y, shadowZ, 1);
        //Get the angle of the hit triangle from the normals.
        floorAngle = abs(radtodeg(arctan2(normalY, normalX)) - 180)
        floorPitch = abs(radtodeg(arccos(-normalZ)) - 180);
    }
    else
    {
        shadowZ = -65536; //-65536 disables shadow rendering
        floorPitch = 0;
    }
//Physics
//Sliding on steep slopes
if (sliding)
{
    //Raycast below to see if we are still under a slope, also check if our floor is actually a slope
    if (c_raycast_world(x, y, z, x, y, bottom - 8, 1) &amp;&amp; floorPitch)
    {
        //Stick onto the slope
        z = c_hit_z() + half;
        //Move down the slope
        var oppositeAngle = abs(floorAngle - 180);
        hSpeed = lengthdir_x(min(abs(hSpeed) + 0.1, abs(lengthdir_x(3, floorPitch))), oppositeAngle);
        vSpeed = lengthdir_y(min(abs(vSpeed) + 0.1, abs(lengthdir_y(3, floorPitch))), oppositeAngle);
    }
    else sliding = false;
}
else if (fOnGround)
{
    //If the floor we are standing on is more than 60 degrees upwards...
    if (floorPitch &gt; 60)
    {
        //Reset speed and start sliding
        hSpeed = 0;
        vSpeed = 0;
        zSpeed = 0;
        sliding = true;
    }
}
else if (fGravity &amp;&amp; zSpeed &gt; -10) zSpeed -= 0.1; //Gravity
//Collision
if !(fGhost)
{
    //Actor collision
    var actorTouch = instance_place(x, y, objActor);
    //If there is a solid actor and I'm pushable... and if I am overlapping the actor...
    if (actorTouch &amp;&amp; actorTouch.fSolid &amp;&amp; fPushable &amp;&amp; bottom &lt; actorTouch.top &amp;&amp; top &gt; actorTouch.bottom)
    {
        //Move out of the way
        var angle = point_direction(x, y, actorTouch.x, actorTouch.y);
        while (place_meeting(x, y, actorTouch))
        {
            if (c_raycast_world(actorTouch.x, actorTouch.y, actorTouch.z, x - lengthdir_x(radius, angle), y - lengthdir_y(radius, angle), z, 1)) break
            x -= lengthdir_x(1, angle);
            y -= lengthdir_y(1, angle);
        }
        enemy_bounce();
    }
    //Floor collision
    var incX = x + hSpeed, incY = y + vSpeed;
    //The actor will not move down regular slopes if it is bouncy.
    if (c_raycast_world(x, y, z, incX, incY, bottom + zSpeed, 1) || (!fBounce &amp;&amp; zSpeed &lt;= 0 &amp;&amp; c_raycast_world(x, y, z, x, y, bottom - (4 + zSpeed), 1)))
    {
        z = c_hit_z() + half;
        actor_bounce_z();
        fOnGround = true;
    }
    else fOnGround = false;
    //Horizontal wall collision
    if (c_raycast_world(incX - radius, incY, z, incX + radius, incY, z, 1))
    {
        var dir = point_direction(x, y, c_hit_x(), c_hit_y());
        x = c_hit_x() - lengthdir_x(radius, dir);
        if (fBounce) hSpeed /= -bounciness;
        else hSpeed = 0;
        enemy_bounce();
    }
    //Vertical wall collision
    if (c_raycast_world(incX, incY - radius, z, incX, incY + radius, z, 1))
    {
        var dir = point_direction(x, y, c_hit_x(), c_hit_y());
        y = c_hit_y() - lengthdir_y(radius, dir);
        if (fBounce) vSpeed /= -bounciness;
        else vSpeed = 0;
        enemy_bounce();
    }
    //Ceiling collision
    //The ceiling always prevents the player from overlapping at all, similarly to SM64.
    if (c_raycast_world(x, y, z, x, y, top + zSpeed, 1))
    {
        x = xprevious;
        y = yprevious;
        z = c_hit_z() - half;
        hSpeed = 0;
        vSpeed = 0;
        if (zSpeed &gt; 0)
            if (fBounce) zSpeed = -zSpeed;
            else zSpeed = 0;
    }
}
x += hSpeed;
y += vSpeed;
z += zSpeed;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="24">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update audio, position &amp; disappear in pits
actor_update();
if (z &lt; global.minZ - 1024) instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
